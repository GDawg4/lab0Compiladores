grammar MyGrammer;
program: meat=classP end=';' # ProgramExpr;
classP: CLASSKEY TYPE (INHERITSKEY TYPE)? '{''}';
//(feature*';')*
// classP: CLASSKEY asdf=TYPE;
// feature: ID(feature1|feature2);
// feature1: '('(formal(',' formal)*)? ')'':'TYPE'{'expr'}';
// feature2:':'TYPE('<-' expr)?;
// formal: ID':'TYPE;
// expr:(id2|IFKEY|WHILEKEY|LETKEY|NEWKEY|ISVOIDKEY|NOTKEY|TrueVariable|FalseVariable|'('|INTEGERS|STRING)expr2(')')?;
// expr2: ((('+'|'-'|'*'|'/'|'<'|'=')expr|('@'TYPE)?'.'ID '('(expr(','expr)*)?')')expr2) | ' ';
// id2: ID (('<-' expr)|('('));

fragment A:[aA];
fragment B:[bB];
fragment C:[cC];
fragment D:[dD];
fragment E:[eE];
fragment F:[fF];
fragment G:[gG];
fragment H:[hH];
fragment I:[iI];
fragment J:[jJ];
fragment K:[kK];
fragment L:[lL];
fragment M:[mM];
fragment N:[nN];
fragment O:[oO];
fragment P:[pP];
fragment Q:[qQ];
fragment R:[rR];
fragment S:[sS];
fragment T:[tT];
fragment U:[uU];
fragment V:[vV];
fragment W:[wW];
fragment X:[xX];
fragment Y:[yY];
fragment Z:[zZ];
CLASSKEY: C L A S S;
// ELSEKEY: E L S E;
// FALSEKEY: F A L S E;
// FIKEY: F I;
// IFKEY: I F;
// INKEY: I N;
INHERITSKEY: I N H E R I T S;
// ISVOIDKEY: I S V O I D;
// LOOPEY: L O O P;
// POOLKEY: P O O L;
// THENKEY: T H E N;
// WHILEKEY: W H I L E;
// NEWKEY: N E W;
// NOTKEY: N O T;
// TRUEKEY: T R U E;
// LETKEY: L E T;
// TrueVariable: 'true';
// FalseVariable: 'false';
DIGIT: [0-9];
LOWER: [a-z];
UPPER: [A-Z];
TYPE: UPPER(LETTERS|DIGIT)+;
LETTERS: (LOWER|UPPER);
// ANYSET:(LETTERS|DIGIT)+;
// ALPHANUMERIC: (DIGIT|LETTERS);
// INTEGERS: DIGIT+;
// ID: (UPPER|LOWER)+;
// OBJECT: LOWER(LETTERS|DIGIT)+;
// STRING: '"'LETTERS*'"';
// COMMENTS: ('--'ANYSET'\n'|'*'ANYSET'*') -> skip;

WHITESPACE: [ \t\r\n] -> skip;